---
title: "Building a genetic linkage map of an autotetraploid population using MAPpoly"
author: "Marcelo Mollinari, Gabriel Gesteira, Guilherme Pereira, A Augusto Garcia, Zhao-Bang Zeng"
date: '`r Sys.Date()`'
output:
  rmdformats::downcute:
    toc_depth: 3
    lightbox: TRUE
    use_bookdown: TRUE
linestretch: 1.1
bibliography: biblio.bib
---

```{r setup, include = FALSE, eval = TRUE}
require(mappoly)
#load('all_run.RData')
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_chunk$set(eval = TRUE)
```

# Introduction

In this tutorial we will build a hexaploid linkage map ...

You can read CSV files with the `read_geno_csv` function:

## Reading VCF files {#read_vcf}

`MAPpoly` can also handle VCF files (>= V.4.0) generated by the most programs, such as TASSEL, GATK, and Stacks. As few of them can handle poliploidy and estimate genotypes in a satisfactory manner, you may use other tools specifically developed to estimate allele dosages. Briefly, these programs use the allele read counts (or intensity) for each marker $\times$ individual combination, and determines which is the most likely allele dosage. Examples are [SuperMASSA](http://statgen.esalq.usp.br/SuperMASSA/), [fitPoly](https://cran.r-project.org/web/packages/fitPoly/index.html), [ClusterCall](https://potatobreeding.cals.wisc.edu/wp-content/uploads/sites/161/2017/08/ClusterCall_Download.zip), [updog](https://cloud.r-project.org/web/packages/updog/index.html), and  [PolyRAD](https://cran.r-project.org/web/packages/polyRAD/vignettes/polyRADtutorial.html). After allele dosage estimation, your VCF file should contain values for the field GT similar to **1/1/1/0** (a triplex marker in an autotetraploid, for example) rather than **1/0**. Since `MAPpoly` uses dosages (or their probabilities) to build genetic maps, we strongly recommend using programs capable of estimating dosages before building the map. `fitPoly`, `PolyRAD`, and `updog` have direct integration with `MAPpoly`, as will be described in the next sections.

To demonstrate the `read_vcf` function, let us download an autohexaploid sweetpotato VCF file from the `MAPpoly's` vignettes repository on Github and read it:

```{r load_vcf_data}
dat <- NULL
for(i in c(3,9,12)){ #for the complete dataset use 1:12 instead
  cat("Loading chromosome", i, "...")
  x <- "https://github.com/mmollina/MAPpoly_vignettes/raw/master/data/BT/sweetpotato_chr"
  ft <- paste0(x, i, ".vcf.gz")
  tempfl <- tempfile()
  download.file(ft, destfile = tempfl, quiet = TRUE)
  dattemp <- read_vcf(file.in = tempfl, 
                      parent.1 = "PARENT1", 
                      parent.2 = "PARENT2", 
                      verbose = FALSE, 
                      ploidy = 6)
  dat <- merge_datasets(dat, dattemp)
  cat("\n")
}
unlink(tempfl)
plot(dat)
print(dat, detailed = TRUE)
```


```{r inspect_depth}
library(ggplot2)
dosage_combs = cbind(dat$dosage.p, dat$dosage.q)
dc_simplex = apply(dosage_combs,1,function(x) if(all(c(0,1) %in% x) | 
                                                 all(c(dat$m-1, dat$m) %in% x)) return(TRUE) else return(FALSE))
dc_dsimplex = apply(dosage_combs,1,function(x) if(all(x == c(1,1)) | 
                                                  all(x == c(dat$m-1, dat$m-1))) return(TRUE) else return(FALSE))

dc_simplex[which(dc_simplex == TRUE)] = "simplex"
dc_simplex[which(dc_dsimplex == TRUE)] = 'double simplex'
dc_simplex[which(dc_simplex == 'FALSE')] = 'multiplex'

data_depths = data.frame('Marker depths' = dat$all.mrk.depth,
                         'Depth classes' = findInterval(dat$all.mrk.depth, c(200,300,400,500,600,50000)),
                         'Dosage combinations' = dc_simplex, check.names = F)

ggplot(data_depths, aes(fill=`Dosage combinations`, x=`Depth classes`, y=`Marker depths`)) +
  geom_bar(position = 'stack', stat = 'identity') +
  scale_x_continuous(breaks=0:5, labels=c("[0,200)","[200,300)","[300,400)","[400,500)","[500,600)", "> 600"))
```


# Filtering and Quality Control
## Missing data filtering

The function `filter_missing` filters out markers and/or individuals that exceeds a defined threshold of missing data. The argument `input.data` should contain your dataset object, and you can choose to filter either by 'marker' or 'individual' using the `type` argument (string). You can also define the maximum proportion of missing data using the `filter.thres` argument (ranges from 0 to 1, i.e. a threshold of 0.05 will keep just markers or individuals with less than 5% of missing data). When `TRUE` (default), the `inter` argument plots markers or individuals vs. frequency of missing data.

```{r filter_missing}
# Filtering dataset by marker
dat <- filter_missing(input.data = dat, type = "marker", 
                               filter.thres = 0.10, inter = TRUE)
```

```{r}
# Filtering dataset by individual
dat <- filter_missing(input.data = dat, type = "individual", 
                               filter.thres = 0.05, inter = TRUE)   

```

## Segregation test

```{r chisq_test}
pval.bonf <- 0.05/dat$n.mrk
mrks.chi.filt <- filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = TRUE)
seq.init <- make_seq_mappoly(mrks.chi.filt)
plot(seq.init)
```

# Two-point analysis{#tpt}


```{r two_pt}
# Defining number of cores
n.cores = parallel::detectCores() - 1
#(~ 33 minutes using 23 cores)
all.rf.pairwise <- est_pairwise_rf(input.seq = seq.init, ncpus = n.cores)
all.rf.pairwise
```

To assess the recombination fraction between a particular pair of markers, say markers 2204 and 4508, you can use the following

## Assembling recombination fraction and LOD Score matrices

```{r rf_mat, echo=TRUE}
mat <- rf_list_to_matrix(input.twopt = all.rf.pairwise)
```


```{r plot_full_mat, fig.width=7, fig.height=7}
s <- rf_snp_filter(all.rf.pairwise, 
                   thresh.LOD.ph = 5, 
                   thresh.LOD.rf = 5,
                   thresh.rf = 0.15, 
                   probs = c(0.05, 1))
id<-get_genomic_order(s)
s.o <- make_seq_mappoly(id)
plot(mat, ord = s.o$seq.mrk.names, fact = 5)
```

# Assembling linkage groups



```{r group}
mf <- make_mat_mappoly(mat, s.o)
grs <- group_mappoly(input.mat = mf,
                     expected.groups = 3,
                     comp.mat = TRUE, 
                     inter = TRUE)
grs
plot(grs)
```


```{r make_lgs}
# genome correspondence
z <- as.numeric(colnames(grs$seq.vs.grouped.snp)[1:3])
LGS <- vector("list", 3)
names(LGS) <- c(3,9,12)
for(j in 1:3){
    temp1 <- make_seq_mappoly(grs, j, genomic.info = 1)
    tpt <- make_pairs_mappoly(all.rf.pairwise, input.seq = temp1)
    temp2 <- rf_snp_filter(input.twopt = tpt, diagnostic.plot = FALSE)
    lgtemp <- get_genomic_order(temp2)
    LGS[[as.character(z[j])]] <- list(lg = make_seq_mappoly(lgtemp), tpt = tpt)
}
```



```{r, map_lg3}
m1 <- make_mat_mappoly(mat , LGS[[1]]$lg)
o1 <- mds_mappoly(m1)
s1 <- make_seq_mappoly(o1)
#s1 <- make_seq_mappoly(dat, s1$seq.mrk.names[ceiling(seq(1, 2075, length.out = 100))])
#plot(s1$sequence.pos)
system.time(lg1.map <- est_rf_hmm_sequential(input.seq = s1,
                                start.set = 3,
                                thres.twopt = 10, 
                                thres.hmm = 50,
                                extend.tail = 100,
                                info.tail = TRUE, 
                                twopt = LGS[[1]]$tpt,
                                sub.map.size.diff.limit = 5, 
                                phase.number.limit = 20,
                                reestimate.single.ph.configuration = TRUE,
                                tol = 10e-2,
                                tol.final = 10e-3))
```

Now, use the functions `print` and `plot` to view the results:

```{r map_lg10_plot, fig.width=10}
print(lg10.map)
plot(lg10.map)
plot(mat, ord = lg10.map$info$mrk.names, fact = 3)
```

In the previous figure, black rectangles indicate the presence of the allelic variant in each one of the four homologous in both parents (**a**,**b**,***c** and, **d** in parent 1, and **e**, **f**, **g**, and **h** in parent 2). One also can print a detailed version of the map and plot a specific map segment using the following code.

```{r, eval=FALSE}
print(lg10.map, detailed = TRUE)
```
```{r, echo=TRUE, fig.width=7, fig.height=7}
plot(lg10.map, left.lim = 30, right.lim = 40, mrk.names = TRUE) 
```

## Reestimating map using genotype probabilities

Though current technologies enabled the genotyping of thousands of SNPs, they are prone to genotyping errors, especially in polyploid species. To address this problem `MAPpoly` uses prior probability distributions for the marker genotypes (as shown [here](#read_prob_geno)), allowing the HMM to update their probability. This procedure can be applied using either the probability distribution provided by the genotype calling software or assuming a global genotype error. For a detailed explanation of this procedure, please see @Mollinari2019. Briefly, the use of a prior information will update the genotype of the markers based on a global chromosome structure. If the probability didtribution of the genotypes is abailable, one can update the map using 

```{r, map_prior1_lg10}
lg10.map.prob <- est_full_hmm_with_prior_prob(input.map = lg10.map)
plot(lg10.map.prob)
```
If the user wants to assume a global genotyping error, say 5%, they should use
```{r, map_prior_lg10}
lg10.map.err <- est_full_hmm_with_global_error(input.map = lg10.map, error = 0.05)
plot(lg10.map.err)
```

With a global genotyping error of 5% the resulting map was smaller than the previous maps. Although a smaller map is usually associated with a "high quality" map, this is just a consequence of a much more critical update prompted by the re-estimation procedure: eliminating spurious crossing over event, allowing clear recombination patterns in haplotype reconstruction. We will show an example in a [future section](#haplotype). 

## Reinserting redundant markers

As mentioned before, redundant markers are automatically removed during the analysis to reduce computational calculations. However, one may want to see the genetic linkage maps considering all markers in the full dataset. The addition of redundant markers to a map can be done by just calling the function `update_map`. Here we will show the addition in the previous map:


```{r}
lg10.map.updated = update_map(lg10.map.err)
lg10.map.err
lg10.map.updated
```

In this case, the number of markers was increased by 20, however the length of the map is still the same.

# Ordering markers using MDS and reestimating the map

So far the map was reestimated using the genomic order. However, for some species a good reference genome is not always avaiable and the markers need to be ordered using an optimization technique. Here, we use the MDS (multidimensional scaling) algorithm, proposed in the context of genetic mapping by @Preedy2016. The MDS algorithm requires a recombination fraction matrix, which will be transformed in distances using a mapping function (in `MAPpoly`'s case the Haldane's mapping function). First, let us gather the pairwise recombination fractions for all linkage groups:

```{r mat_for_ordering, results='hide', results=FALSE}
mt <- lapply(LGS, function(x) rf_list_to_matrix(x$tpt))
```

Now, for each matrix contained in the object `mt`, we apply the MDS algorithm:

```{r mds, results='hide', results=FALSE}
mds.ord <- lapply(mt, mds_mappoly)
```

Usually at this point, the user can make use of diagnostic plots to remove markers that are disturbing the ordering procedure. Here we didn't use that procedure, but we encourage the user to check the example in `?mds_mappoly`. Now, let us compare the estimated and the genomic orders (feel free to run the last commented line and see interactive plots):

```{r compare_order}
LGS.mds<-vector("list", 12)
for(j in 1:12){
  lgtemp <- make_seq_mappoly(mds.ord[[j]])
  LGS.mds[[j]] <- list(lg = lgtemp, 
      tpt = make_pairs_mappoly(all.rf.pairwise, input.seq = lgtemp))
}
```

```{r, results='hide', fig.width=10}
geno.vs.mds <- NULL
for(i in 1:length(LGS.mds)){
  geno.vs.mds<-rbind(geno.vs.mds,
                     data.frame(mrk.names = LGS.mds[[i]]$lg$seq.mrk.names,
                                mds.pos = seq_along(LGS.mds[[i]]$lg$seq.mrk.names),
                                genomic.pos = order(LGS.mds[[i]]$lg$sequence.pos),
                                LG = paste0("LG_", i)))
}

require(ggplot2)
p<-ggplot(geno.vs.mds, aes(genomic.pos, mds.pos)) +
  geom_point(alpha = 1/5, aes(colour = LG)) +
  facet_wrap(~LG) +  xlab("Genome Order") + ylab("Map Order")
p
```

Although it is possible to observe local inconsistencies, the global diagonal pattern indicates a consistent order for all linkage groups using both approaches. Now, let us build the genetic map of linkage group 10 using the MDS order

```{r, map_lg10_mds, results=FALSE}
lg10.map.mds <- est_rf_hmm_sequential(input.seq = LGS.mds[[10]]$lg,
                                      start.set = 10,
                                      thres.twopt = 10, 
                                      thres.hmm = 10,
                                      extend.tail = 30,
                                      info.tail = TRUE, 
                                      twopt = LGS.mds[[10]]$tpt,
                                      sub.map.size.diff.limit = 10, 
                                      phase.number.limit = 20,
                                      reestimate.single.ph.configuration = TRUE,
                                      tol = 10e-3,
                                      tol.final = 10e-4)
```

And plot the map:

```{r plot_mds_map}
plot(lg10.map.mds)
```

It is also possible to compare the maps using both genome-based and MDS-based orders with the function `plot_map_list`:

```{r lg10_map_mds_plot, results='hide', fig.width=10, fig.height=5}
plot_map_list(list(genome = lg10.map, mds = lg10.map.mds), col = c("#E69F00", "#56B4E9"), title = "")
```
The genome-based map included 210 markers while the MDS included 222 markers. The smaller size of the genome-based could be interpreted as a better result. Howvere, since it has less markers, this outcome was expected. To formally compare the maps, let us select the markers present in both maps and reestimate them to compare their likelihoods. 

```{r map_comp}
mrks.in.gen<-intersect(lg10.map$maps[[1]]$seq.num, lg10.map.mds$maps[[1]]$seq.num)
mrks.in.mds<-intersect(lg10.map.mds$maps[[1]]$seq.num, lg10.map$maps[[1]]$seq.num)
if(cor(mrks.in.gen, mrks.in.mds) < 0){
  mrks.in.mds <- rev(mrks.in.mds)
  lg10.map.mds <- rev_map(lg10.map.mds)
}
map.comp.3.gen<-get_submap(input.map = lg10.map, match(mrks.in.gen, lg10.map$maps[[1]]$seq.num), verbose = FALSE)
map.comp.3.mds<-get_submap(input.map = lg10.map.mds, match(mrks.in.mds, lg10.map.mds$maps[[1]]$seq.num), verbose = FALSE)
prob.3.gen<-extract_map(lg10.map)
prob.3.mds<-extract_map(lg10.map.mds)
names(prob.3.gen)<-map.comp.3.gen$maps[[1]]$seq.num
names(prob.3.mds)<-map.comp.3.mds$maps[[1]]$seq.num
```

```{r, results='hide', fig.align='center'}
matplot(t(data.frame(prob.3.gen,prob.3.mds[names(prob.3.gen)])), 
        type="b", pch="_", col=1, lty=1, lwd = .5, xlab= "", 
        ylab="Marker position (cM)", axes = F)
axis(2)
mtext(text = round(map.comp.3.gen$maps[[1]]$loglike,1), side = 1, adj = 0)
mtext(text = round(map.comp.3.mds$maps[[1]]$loglike,1), side = 1, adj = 1)
mtext(text = "Genomic", side = 3, adj = 0)
mtext(text = "MDS", side = 3, adj = 1)
```

Notice that these maps have the same local inversions shown in the dot plots presented earlier. In this case, the log-likelihood of the genomic order is higher than the one obtained using the MDS order. For this linkage group, we have a statistical support to 

# Parallel map construction
## Using one core by LG

Now, the mapping procedure will be applied to all linkage groups using parallelization. Although users must be encouraged to compare both MDS and genomic orders following the previous example, the genomic order will be considered as an example (remember that this step will take a **long time** to run):

```{r hmm_map, results=FALSE}
## ~13.3 min
## Performing parallel computation
my.phase.func<-function(X){
  x<-est_rf_hmm_sequential(input.seq = X$lg,
                                start.set = 10,
                                thres.twopt = 10, 
                                thres.hmm = 10,
                                extend.tail = 30,
                                info.tail = TRUE, 
                                twopt = X$tpt,
                                sub.map.size.diff.limit = 8, 
                                phase.number.limit = 10,
                                reestimate.single.ph.configuration = TRUE,
                                tol = 10e-3,
                                tol.final = 10e-4)
  return(x)
}
cl <- parallel::makeCluster(12)
parallel::clusterEvalQ(cl, require(mappoly))
parallel::clusterExport(cl, "dat")
MAPs <- parallel::parLapply(cl,LGS,my.phase.func)
parallel::stopCluster(cl)

```

A traditional linkage map plot can be generated including all linkage groups, using the function `plot_map_list`:

```{r print_maps, fig.width=10} 
plot_map_list(MAPs, col = "ggstyle")
```

Following the reconstruction of LG 3 shown before, let us consider a global genotyping error of 5% to reestimate the final maps:

```{r reestimate_map_with_error, results=FALSE}
my.error.func<-function(X){
  x<-est_full_hmm_with_global_error(input.map = X, 
                                    error = 0.05, 
                                    tol = 10e-4, 
                                    verbose = FALSE)
  return(x)
}
cl <- parallel::makeCluster(12)
parallel::clusterEvalQ(cl, require(mappoly))
parallel::clusterExport(cl, "dat")
MAP.err <- parallel::parLapply(cl,MAPs,my.error.func)
parallel::stopCluster(cl)
```

Comparing both results:

```{r final_plot, fig.width=10, fig.height=8}
all.MAPs <- NULL
for(i in 1:12) 
  all.MAPs<-c(all.MAPs, MAPs[i], MAP.err[i])
plot_map_list(map.list = all.MAPs, col = rep(c("#E69F00", "#56B4E9"), 12))
```

Then, the map that included modeling of genotype errors was chosen as the best one.

```{r print_err_maps, fig.width=10} 
plot_map_list(MAP.err, col = "ggstyle")
```

## Map vs. genome

````{r}
plot_genome_vs_map(MAP.err, same.ch.lg = TRUE)
````

## Map summary

After building two or more maps, one may want to compare summary statistics of those maps regarding the same chromosome, or even across chromosomes. A brief comparison can be done using the function `summary_maps`, which generates a table containing these statistics based on a list of `mappoly.map` objects:

```{r}
knitr::kable(summary_maps(MAPs))
```

## Export map 

```{r}
require(polymapR)
dat1<-export_data_to_polymapR(hexafake)
F1checked <- checkF1(dosage_matrix = dat1, 
                     parent1 = "P1",
                     parent2 = "P2",
                     F1 = colnames(dat)[-c(1:2)],
                     polysomic = TRUE, 
                     disomic = FALSE, 
                     mixed = FALSE, 
                     ploidy = 6)
 head(F1checked$checked_F1)
```

# Genotype conditional probabilities

In order to use the genetic map in [QTLpoly](https://github.com/guilherme-pereira/QTLpoly), one needs to obtain the conditional probability of all possible 36 genotypes along the 12 linkage groups for all individuals in the full-sib population. Let us use the function `calc_genoprob_error`, which similarly to `est_full_hmm_with_global_error` allows the inclusion of a global genotyping error:

```{r genoprob_2, results=FALSE}
genoprob.err <- vector("list", 12)
for(i in 1:12)
   genoprob.err[[i]] <- calc_genoprob_error(input.map = MAP.err[[i]], error = 0.05)
```

Here, a global genotyping error of 5% was used. Each position of any object in the list `genoprob.err` contains two elements: an array of dimensions $36 \times number \; of \; markers \times  number \; of \; individuals$ and the position of the markers in the maps in centimorgans.  Let us display the results for all linkage groups in individual 1:

```{r plot_genoprob_all, fig.width=10, fig.height=8}
ind <- 1
op <- par(mfrow = c(3, 4), pty = "s", mar=c(1,1,1,1)) 
for(i in 1:12)
{
  d <- genoprob.err[[i]]$map
  image(t(genoprob.err[[i]]$probs[,,ind]),
        col=RColorBrewer::brewer.pal(n=9 , name = "YlOrRd"),
        axes=FALSE,
        xlab = "Markers",
        ylab = "",
        main = paste("LG", i))
  axis(side = 1, at = d/max(d),
       labels =rep("", length(d)), las=2)
}
par(op)
```

In this figure, the x-axis represents the genetic map and the y-axis represents the 36 possible genotypes in the full-sib population. The color scale varies from dark purple (high probabilities) to light yellow (low probabilities). With the conditional probabilities computed, it is possible to use the object `genoprob.err` alongside with phenotypic data as the input of the software [QTLpoly](https://github.com/guilherme-pereira/QTLpoly), which is an under development software to map multiple QTLs in full-sib families of outcrossing autopolyploid species.

# Obtaining individual haplotypes {#haplotype}

Once ready, the genotypic conditional probabilities can be used to recover any individual haplotype given the map (details described in @Mollinari2020). To generate this information, one may use the function `calc_homoprob` to account for the probabilities of each homologous, in all map positions for each individual. For example, let us view the homologous probabilities for chromosome 1 and individual 10:

```{r, haplotypes}
homoprobs = calc_homoprob(genoprob.err)
```

```{r}
plot(homoprobs, lg = 1, ind = 10)
```

Using this graphic, it is possible to identify regions of crossing-over occurrence, represented by the inversion of probability magnitudes between homologous from the same parent. It is also possible to view all chromosomes at the same time for any individual by setting the parameter `lg = "all"`. One may use this information to evaluate the quality of the map and repeat some processes with modifications, if necessary.

# Evaluating the meiotic process

MAPpoly also handles a function to evaluate the meiotic process that guided gamete formation on the studied population. Given genotype conditional probabilities, one may want to account for homologous pairing probabilities and detect the occurrence of preferential pairing, which is possible through the function `calc_prefpair_profiles`:

```{r, meiosis_evaluation}
prefpairs = calc_prefpair_profiles(genoprob.err)
```

The function returns an object of class `mappoly.prefpair.profiles`, which was saved as `prefpairs`. This object handles all information necessary to study pairing, such as the probability for each pairing configuration ($\psi$; see @Mollinari2019) inside each parent. For a more user-friendly visualization of the results, one may want to look at the `plot` output:

```{r, meiosis_evaluation_plot}
plot(prefpairs)
#save.image("all.analysis.rda")
```

This graphic shows information about all pairing configurations and their probabilities, the proportion of bivalent/multivalent pairing, and also the p-value for preferential pairing test for all markers inside each parent.


# References

